# CCS_BAM-filter.shinyapp
# A R/shiny tool to filter CCS data and make plot
# VIB Nucleomics Core (author: Stephane Plaisance)
# 2020-11-19 v1.0

library("shiny")
library("shinyBS")
library("shinyjs")
library("shinymanager")
library("markdown")
#library("stringi")
#library("reshape2")
library("readr")
library("DT")
library("ggplot2")
library("grid")
library("gridExtra")
library("ggpubr")

# App defaults
app.name <- "CCS_BAM-filter"
version <- "Version: 1.0.1 - 2020-11-24"
versnum <- "v1.0.1"

# load path to Uploads
source("config.R")

# you may un-comment the next line to allow 10MB input files
options(shiny.maxRequestSize = 20 * 1024 ^ 2)

textInput3 <- function (inputId, label, value = "", ...) {
  div(
    style = "display:inline-block",
    tags$label(label, `for` = inputId),
    tags$input(
      id = inputId,
      type = "text",
      value = value,
      ...
    )
  )
}

Nvalue <- function(lim, x, na.rm = TRUE) {
  # handle NA values
  if (isTRUE(na.rm)) {
    x <- x[!is.na(x)]
  }
  cutval <- 100 / lim
  # compute LXX and NXX
  sorted <- sort(x, decreasing = TRUE)
  SXX <- sum(x) / cutval
  csum <- cumsum(sorted)
  GTLXX <- as.vector(csum >= SXX)
  LXX = min(which(GTLXX == TRUE))
  NXX <- round(sorted[LXX], 1)
  # eg: get NXX with lst['NXX']
  NXX
}

ui <- navbarPage(
  paste0(app.name, "! ", versnum),
  id = "tabSwitch",
  tabPanel("Data Upload",
           sidebarLayout(
             sidebarPanel(
               tags$h4(tags$i(
                 "Analyze BAM data obtained from a PacBio CCS analysis"
               )),
               tags$p(
                 "The reads will be subjected to filtering accoring to your chosen limits and the resulting data used to create plots and reveal trends in your data."
               ),
               tags$p(
                 "The filtered reads can be downloaded to your computer (BAM format) and fed to downstream tools of your choice."
               ),
               tags$p(
                 "Note: The size of the BAM file should be less than 100Mb. For larger files, we recommend to install this shiny application (and its dependencies) on your own server from our GitHUB copy, see 'Info/About'."
               ),
               tipify(
                 fileInput('BAM', 'Upload a CCS BAM File', accept = '.bam'),
                 "the Data is a BAM file generated by a PacBio CCS analysis"
               ),
               actionButton("importBAM", "import and analyze", icon =
                              icon('upload'))
             ),
             mainPanel()
           )),
  tabPanel("Analyze CSS",
           sidebarLayout(
             sidebarPanel(
               img(src = "CCS.png", style = 'padding-right:10px;height:123px;width:238px'),
               br(),
               tags$h4(tags$i("CCS BAM filtering")),
               tags$p("Choose limits using the controls below."),
               # subread length range
               tags$h5("Insert length"),
               numericInput(
                 inputId = "minlen",
                 label = "min",
                 value = 0
               ),
               numericInput(
                 inputId = "maxlen",
                 label = "max",
                 value = 1000000
               ),
               # CCS minimum passes
               tags$h5("Number of passes"),
               numericInput("minpass",
                            label = "at least",
                            value = 1),
               tags$h5("Accuracy"),
               # CCS minimum accuracy
               numericInput("minaccuracy",
                            label = "at least",
                            value = 0.99),
               br(),
               actionButton("filter", "apply filters", icon =
                              icon('filter')),
               hr(),
               actionButton(
                 "filterBam",
                 "create filtered BAM",
                 icon =
                   icon('filter', lib = "glyphicon")
               ),
               hr(),
               downloadButton(
                 "downloadBam",
                 "download filtered BAM",
                 icon =
                   icon('save', lib = "glyphicon")
               ),
               width = 2
             ),
             mainPanel(
               dataTableOutput('ccs_data'),
               downloadButton("downloadPlot", "save plot", icon =
                                icon('save', lib = "glyphicon")),
               hr(),
               plotOutput('plots')
             )
           ), ),
  tabPanel("Download filtered CSS Data"),
  navbarMenu(
    "Info",
    tabPanel("About",
             fluidRow(
               column(
                 3,
                 br(),
                 br(),
                 img(src = 'logo.png', width = 200),
                 br(),
                 tags$small(a(href = "https://www.nucleomics.be", "VIB Nucleomics Core"))
               ),
               column(6,
                      includeMarkdown("www/about.md"))
             )),
    tabPanel("License",
             fluidRow(column(
               6,
               includeMarkdown("www/license.md")
             ))),
    tabPanel("Version",
             helpText(version))
  ),
  # initialize Shinyjs: used for click()
  useShinyjs()
  
  # ui ends here
)

# Define server logic required to draw a histogram
server <- function(input, output) {
  # clean old data
  file.remove(file.path(uploads, "data.bam"))
  file.remove(file.path(uploads, "data.txt"))
  file.remove(file.path(uploads, "reads_list.txt"))
  file.remove(file.path(uploads, "data_filtered.bam"))
  
  # get user to select a BAM file to process
  BamFile <- reactive({
    file <- input$BAM
    req(file)
    fpath <- file$datapath
    fext <- tools::file_ext(fpath)
    validate(need(fext %in% c("bam", "BAM"), "Upload must be a .bam or .BAM file"))
    res <-
      list(
        upath = file$datapath,
        fname = basename(file$name),
        fext = fext
      )
    return(res)
  })
  
  # upload BAM file
  observeEvent(input$importBAM, {
    isolate(BamFile()$upath)
    upload_result <- list()
    # copy file to server
    err0 <- file.copy(BamFile()$upath, uploads)
    err1 <- file.remove(file.path(uploads, "data.bam"))
    err2 <- file.remove(file.path(uploads, "data.txt"))
    err3 <- file.rename(file.path(uploads, paste0("0.", BamFile()$fext)),
                  file.path(uploads, "data.bam"))
    if (!err3) {
      upload_result <- c(upload_result, "FAILED! Error during upload")
    }
    # all went well
    if (length(upload_result) == 0) {
      upload_result <-
        c(upload_result, "The file was uploaded succesfully")
    }
    
    # report to user
    showModal(modalDialog(
      title = "Upload status",
      paste(unlist(upload_result), collapse = ", "),
      easyClose = TRUE,
      footer = NULL
    ))
    
    # create text summary with ccsbam2passdist.sh
    analysis_result <- list()
    a_err0 <-
      system("scripts/ccsbam2passdist.sh Uploads/data.bam Uploads/data.txt")
    if (a_err0) {
      analysis_result <-
        c(analysis_result, "FAILED! analysing the BAM data")
    }
    # all went well
    if (length(analysis_result) == 0) {
      analysis_result <-
        c(analysis_result, "The BAM file was analyzed succesfully")
    }
    
    # report to user
    showModal(modalDialog(
      title = "Analysis status",
      paste(unlist(analysis_result), collapse = ", "),
      easyClose = TRUE,
      footer = NULL
    ))
  })
  
  # get full data
  bamdata <- reactive({
    if (is.null(input$importBAM))
      return(NULL)
    req("Uploads/data.txt")
    df <- read.csv("Uploads/data.txt",
                   header = TRUE,
                   sep = ",")
    return(df)
  })
  
  # create filtered subset
  filtered.data <- eventReactive({
    input$filter
  }, {
    # do nothing in absence of data
    if (is.null(bamdata()))
      return(NULL)
    fdata <- subset(
      bamdata(),
      len >= as.numeric(input$minlen) &
        len <= as.numeric(input$maxlen) &
        npass >= as.numeric(input$minpass) &
        Accuracy >= as.numeric(input$minaccuracy)
    )
    
    # return filtered table
    return(fdata)
  })
  
  # fill data.table with filtered data
  output$ccs_data <- renderDataTable({
    DT::datatable(filtered.data())
  })
  
  # create plots
  pt1 <- reactive({
    if (is.null(filtered.data()))
      return(NULL)
    pdata <- filtered.data()
    # get limits for plots
    minl <- min(pdata$len)
    maxl <- max(pdata$len)
    n50reads <- Nvalue(50, pdata$len)
    minpass <- min(pdata$npass)
    maxpass <- max(pdata$npass)
    n50npass <- Nvalue(50, pdata$npass)
    minaccu <- min(c(0.999, min(pdata$Accuracy)))
    maxaccu <- max(pdata$Accuracy)
    medaccu <- median(pdata$Accuracy)
    ggplot() +
      geom_density(
        data = pdata,
        aes(len, colour = "orange"),
        lwd = 1.25,
        show.legend = FALSE
      ) +
      labs(x = "read length", y = "density") +
      theme_linedraw() +
      theme(plot.title = element_text(margin = margin(b = 0), size = 14)) +
      ggtitle(paste0("CCS length ([", minl, "..", maxl, "], N50=" , n50reads, ")"))
  })
  
  pt2 <- reactive({
    if (is.null(filtered.data()))
      return(NULL)
    pdata <- filtered.data()
    # get limits for plots
    minl <- min(pdata$len)
    maxl <- max(pdata$len)
    n50reads <- Nvalue(50, pdata$len)
    minpass <- min(pdata$npass)
    maxpass <- max(pdata$npass)
    n50npass <- Nvalue(50, pdata$npass)
    minaccu <- min(c(0.999, min(pdata$Accuracy)))
    maxaccu <- max(pdata$Accuracy)
    medaccu <- median(pdata$Accuracy)
    ggplot() +
      geom_density(
        data = pdata,
        aes(npass, colour = "blue"),
        lwd = 1.25,
        show.legend = FALSE
      ) +
      labs(x = "CCS passs number", y = "density") +
      theme_linedraw() +
      theme(plot.title = element_text(margin = margin(b = 0), size = 14)) +
      ggtitle(paste0("pass number", " (>", minpass, ", N50=" , n50npass, ")"))
  })
  
  pt3 <- reactive({
    if (is.null(filtered.data()))
      return(NULL)
    pdata <- filtered.data()
    # get limits for plots
    minl <- min(pdata$len)
    maxl <- max(pdata$len)
    n50reads <- Nvalue(50, pdata$len)
    minpass <- min(pdata$npass)
    maxpass <- max(pdata$npass)
    n50npass <- Nvalue(50, pdata$npass)
    minaccu <- min(c(0.999, min(pdata$Accuracy)))
    maxaccu <- max(pdata$Accuracy)
    medaccu <- median(pdata$Accuracy)
    ggplot() +
      geom_density(
        data = pdata,
        aes(Accuracy, colour = "red"),
        lwd = 1.25,
        show.legend = FALSE
      ) +
      labs(x = "CCS accuracy", y = "density") +
      theme_linedraw() +
      theme(plot.title = element_text(margin = margin(b = 0), size = 14)) +
      coord_flip() +
      ggtitle(paste0(
        "CCS accuracy ([",
        minaccu,
        "..",
        maxaccu,
        "], median=" ,
        medaccu,
        ")"
      ))
  })
  
  pt4 <- reactive({
    if (is.null(filtered.data()))
      return(NULL)
    pdata <- filtered.data()
    # get limits for plots
    minl <- min(pdata$len)
    maxl <- max(pdata$len)
    n50reads <- Nvalue(50, pdata$len)
    minpass <- min(pdata$npass)
    maxpass <- max(pdata$npass)
    n50npass <- Nvalue(50, pdata$npass)
    minaccu <- min(c(0.999, min(pdata$Accuracy)))
    maxaccu <- max(pdata$Accuracy)
    medaccu <- median(pdata$Accuracy)
    ggplot(data = pdata, aes(x = npass, y = Accuracy)) +
      geom_point(pch = 20, cex = 0.75, col = "grey60") +
      labs(x = "CCS pass number", y = "CCS accuracy") +
      stat_density_2d(aes(fill = ..level..), geom = "polygon") +
      scale_fill_gradient(low = "blue", high = "red") +
      geom_hline(
        aes(yintercept = 0.999),
        size = 0.5,
        colour = "green",
        lty = 1
      ) +
      geom_hline(
        aes(yintercept = 0.9999),
        size = 0.5,
        colour = "blue",
        lty = 2
      ) +
      theme_linedraw() +
      theme(plot.title = element_text(margin = margin(b = 0), size = 14),
            legend.position = "none") +
      annotate(
        geom = "text",
        x = minpass + 2 / 3 * (maxpass - minpass),
        y = minaccu + 1 / 4 * (maxaccu - minaccu),
        label = paste0(
          "green line:Q30\n dashed-blue line Q40\ndata: ",
          BamFile()$fname
        ),
        color = "grey25",
        cex = 4
      ) +
      ggtitle(paste0("read-count: ", nrow(pdata)))
  })
  
  pt5 <- reactive({
    if (is.null(filtered.data()))
      return(NULL)
    pdata <- filtered.data()
    # get limits for plots
    minl <- min(pdata$len)
    maxl <- max(pdata$len)
    n50reads <- Nvalue(50, pdata$len)
    minpass <- min(pdata$npass)
    maxpass <- max(pdata$npass)
    n50npass <- Nvalue(50, pdata$npass)
    minaccu <- min(c(0.999, min(pdata$Accuracy)))
    maxaccu <- max(pdata$Accuracy)
    medaccu <- median(pdata$Accuracy)
    ggplot(data = pdata, aes(x = npass, y = len)) +
      geom_point(pch = 20, cex = 0.75, col = "grey60") +
      labs(x = "CCS pass number", y = "CCS length") +
      stat_density_2d(aes(fill = ..level..), geom = "polygon") +
      scale_fill_gradient(low = "blue", high = "red") +
      theme_linedraw() +
      theme(plot.title = element_text(margin = margin(b = 0), size = 14),
            legend.position = "none") +
      ggtitle("length vs CCS count")
    })
  
  pt0 <- reactive({
    if (is.null(filtered.data()))
      return(NULL)
    ggplot() + theme_void()
  })
  
  plotData <- reactive({
    ptlist <- list(pt0(), pt2(), pt1(), pt5(), pt4(), pt3())
    grid.arrange(grobs = ptlist,
                 nrow = 2,
                 ncol = 3)
  })
  
  output$plots <- renderPlot({
    print(plotData())
  },
  height = 800, width = 1200)
  
  observeEvent(input$filterBam, {
    fbam <- gsub(".bam", "_filtered.bam", BamFile()$fname)
    # export read list to text file
    rlist <- filtered.data()
    write.table(
      x = rlist$readID,
      file = file.path(uploads, "reads_list.txt"),
      row.names = FALSE,
      col.names = FALSE,
      quote = FALSE
    )
    # create filtered BAM with getReadsByName.sh
    bam_filter_results <- list()
    b_err1 <-
      system("scripts/getReadsByName.sh Uploads/data.bam Uploads/reads_list.txt")
    if (b_err1) {
      bam_filter_results <-
        c(bam_filter_results, "FAILED! filtering the BAM data")
    }
    # all went well
    if (length(bam_filter_results) == 0) {
      bam_filter_results <-
        c(bam_filter_results, "The filtered BAM file was produced")
    }
    
    # report to user
    showModal(modalDialog(
      title = "BAM extraction status",
      paste(unlist(bam_filter_results), collapse = ", "),
      easyClose = TRUE,
      footer = NULL
    ))
  })
  
  output$downloadBam <- downloadHandler(
    filename = function() {
      gsub(".bam", "_filtered.bam", BamFile()$fname)
    },
    content = function(file) {
      serverfile <- paste0(uploads,"/data_filtered.bam")
      file.copy(serverfile, file)
    }
  )
  
  
  output$downloadPlot <- downloadHandler(
    filename = function() {
      gsub(".bam", ".pdf", BamFile()$fname)
    },
    content = function(file) {
      ggsave(file, plotData(), width = 10, height = 10)
    }
  )
  
}

# Run the application
shinyApp(ui = ui, server = server)
