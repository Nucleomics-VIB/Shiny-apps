# This is a Shiny web application showing the current status of the FreeNAS
# storage on R710. It relies on data generated by a cron job every night
# andf therefore may not be up-to-date
# SP:NC, 2018 version 1.0
# 1.0.1 2018-11-22 format numbers in table

library("shiny")
library("readr")
library("DT")
library("ggplot2")
library("lubridate")
library("RColorBrewer")

# you may uncomment the next line to allow large input files
# options(shiny.maxRequestSize=1000*1024^2)
# the following test checks if we are running on shinnyapps.io to limit file size dynamically
# ref: https://stackoverflow.com/questions/31423144/how-to-know-if-the-app-is-running-at-local-or-on-server-r-shiny/31425801#31425801
if ( Sys.getenv('SHINY_PORT') == "" ) { options(shiny.maxRequestSize=1000*1024^2) }

script.version="1.0.1"

# path to the log
dulogfile="/var/tmp/du.log"
dflogfile="/var/tmp/df.log"
base="/mnt/freenas/shared/"

# Define UI for application that draws a histogram
ui <- fluidPage(
  
  # Application header 
  headerPanel(
    "NucCore backup status"
    #div("NC FreeNAS backup status", style = "font-size: 75%")
  ),
  
  # Application title
  titlePanel(windowTitle = "NucCore backup status",
             tags$a(href="https://corefacilities.vib.be/nc", target="_blank", 
                    img(src='logo.png', align = "right", width="150", height="58.5", alt="VIB Nucleomics Core"))
  ),
  
  # Sidebar with a slider input for number of bins 
  sidebarLayout(
    sidebarPanel(
      uiOutput("choose_time"),
      br(),
      sliderInput("depth",
                  "Path depth:",
                  min = 1,
                  max = 1,
                  value = 1,
                  step = 1),
      br(),
      downloadButton("downloadScript", label = "Download bash logging script")
    ),
    
    # Show a plot of the generated distribution
    mainPanel(
      textOutput("currDate"),
      plotOutput("piePlot"),
      div(tableOutput('dftable'), style = "font-size: 75%; width: 75%"),
      div(DT::dataTableOutput("Table"), style = "font-size: 75%; width: 75%")
    )
  )
)

# Define server logic required to draw a histogram
server <- function(input, output, session) {
  
  output$downloadScript <- downloadHandler(
    filename <- function() {
      paste("code", "zip", sep=".")
    },
    
    content <- function(file) {
      file.copy("www/code.zip", file)
    },
    contentType = "application/zip"
  )
  
  # load and process du.log
  du <- read_csv(dulogfile,
                 col_names = c("time.s","date","path","size")
  )
  
  df <- read_csv(dflogfile,
                 col_names = c("time.s","date","used","remaining","used%")
  )
  df <- as.data.frame(df)
  df$date <- as.character(as_datetime(as.numeric(df$time.s), tz="Europe/Brussels"))
  
  # remove path head
  du$path <- gsub(base,"",du$path)
 
  # add more columns
  du$list <- as.list(strsplit(du$path, "/"))
  du$depth <- lapply(du$list,length)
  max.depth <- max(unlist(du$depth))
  
  # latest data = current
  sel.time <- max(du$time.s)
  
  # convert to date
  sel.date <- as_datetime(sel.time, tz="Europe/Brussels")
  
  # unique list of named timestamps
  timelist <- setNames(unique(du$time.s),as_datetime(unique(du$time.s), tz="Europe/Brussels"))
  
  # update slider
  observe({
    val <- input$depth
    updateSliderInput(session, 
                      "depth",
                      max=max.depth)
  })
  
  output$choose_time <- renderUI({
    selectInput("timestamp", 
                "Timestamp",
                timelist,
                selected=max(du$time.s)
    )
  })
  
  curr.data <- reactive({
    if (is.null(du)) return(NULL)
    # react on slider changes
    # filter at depth and time
    curr.sel <- subset(du, du$depth==input$depth & du$time.s==as.numeric(input$timestamp))
    curr.data <- as.data.frame(curr.sel[,c('path','size')])
    curr.data$path <- factor(curr.data$path, levels = curr.data$path[order(curr.data$size)])
    format(curr.data$size, nsmall=1, big.mark=",")
    # return filtered data.frame
    curr.data$size <- format(curr.data$size, big.mark=',', scientific=FALSE) 
    curr.data
  })
  
  curr.df <- reactive({
    if (is.null(df)) return(NULL)
    # filter on timestamp
    df.sel <- subset(df, df$time.s==as.numeric(input$timestamp))
    df.sel[,2:5]
  })
  
  output$currDate <- renderText({
    sel.date <- as_datetime(as.numeric(input$timestamp), tz="Europe/Brussels")
    paste("Update: ", sel.date)
  })
  
  output$piePlot <- renderPlot({
    if (is.null(curr.data())) return(NULL)
    blank_theme <- theme_minimal()+
      theme(
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.border = element_blank(),
        panel.grid=element_blank(),
        axis.ticks = element_blank(),
        plot.title=element_text(size=14, face="bold")
      )
    
    colourCount <- nrow(curr.data()) # number of levels
    getPalette <- colorRampPalette(brewer.pal(9, "Set1"))

    # Barplot
    curr.bp <- ggplot(curr.data(), aes(x="", y = size, fill=path))+
      geom_bar(width = 1, stat = "identity") +
      scale_fill_manual(values = colorRampPalette(brewer.pal(12,"Accent"))(colourCount)) +
      blank_theme
    
    #scale_fill_brewer(palette=coul) +
        
    # convert to pie
    curr.pie <- curr.bp + coord_polar("y", start=0)
    curr.pie + theme(axis.text.x=element_blank())
  })

  output$dftable <- renderTable({
    curr.df()
    })  
  
  output$Table = DT::renderDataTable(
    curr.data(), options = list(columnDefs = list(list(
      className = 'dt-right', targets = '_all'
    )))
    )
}

# Run the application 
shinyApp(ui = ui, server = server)
